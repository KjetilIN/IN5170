\section{General Questions}


\subsection{Problem 1: Interference and AMO}

Consider the following program:

\begin{lstlisting}
    co 
        <x:= x + y> // P1
    ||
        <y:= y + x> // P2
    oc
\end{lstlisting}

\textit{Is the program Interference free?} \\

To check it we can write the v and w variables:

\[
v_{P1} = \{x, y\}, w_{P1} = \{x\}
\]

\[
v_{P2} = \{x, y\}, w_{P2} = \{y\}
\]

Checking if the read and write interfere:

\[
    v_{P1} \land w_{P2} = \{y\} \neq \emptyset
\]

\[
    v_{P2} \land w_{P1} = \{x\} \neq \emptyset
\]

We see there are interference in the program, since neither union of read and write variables are empty set. \\


\textit{Does the two assignment satisfy AMO-property?} \\

Since two assignments does not satisfy the AMO property since.
We can verify this by using the AMO rule for assignments. 
It assigns a critical reference and it is also referenced in the other process. 
This means that the order of operations would lead to different results. 
It does not fulfills the AMO property. 

\subsection{Problem 2: fairness}

Explain the difference between weak and strong fairness. \\

\textbf{Solution} \\

Fairness ensures that enabled statements should not be systematically be neglected by the scheduling strategy.
We use conditions that are enabled or disabled. Both has to be \textit{unconditional fair}. 
A scheduling strategy is unconditional fair if each enabled unconditional atomic action will eventually be chosen. 

\textit{Weak fairness} is when a condition gets enabled and stays enabled, then it will execute. 
Under \textit{strong fairness} if a condition is infinitely enabled, then it will execute. 

\subsection{Problem 3: promise and future}

Explain the difference between promises and futures. \\

\textbf{Solution} \\

A \textbf{future} is an abstraction used to represent the result of an asynchronous computation. 
It acts as a read-only handle for the caller, allowing it to access the result of the computation once it is available, 
and synchronize with the callee by waiting for the result or registering callbacks for when the result is ready.

In simpler terms, a future can be thought of as a mailbox that holds the return value of a task. 
Once the task is completed, the future contains the result. Futures can typically be read multiple times.
Also allow the caller to wait (block) or register a callback to handle the result asynchronously. \\

A \textbf{promise}, on the other hand, is a writable counterpart to a future. 
\begin{enumerate}
    \item It is used to manually set or \"fulfill\" the value of a future.
    \item Promises allow the producer (whoever completes the task) to signal that the computation is complete and provide the result.
\end{enumerate}

Key Differences:
\begin{enumerate}
    \item A future is the read-only handle used by the caller to access the result.
    \item A promise is the write-access handle used by the producer (or callee) to fulfill the result.
\end{enumerate}

Properties:
\begin{enumerate}
    \item Futures can be read multiple times but cannot be written to directly.
    \item Promises are write-once: they must be completed exactly once, either with a value or an error, and are often used to produce a future. 
\end{enumerate}

For example:
\begin{itemize}
    \item The caller creates a promise and obtains a future associated with it.
    \item The callee completes the promise, thereby fulfilling the future.
\end{itemize}
This separation ensures that the caller and callee can operate independently, decoupling the production and consumption of the computation result.

\subsection{Problem 4: future and linear channels}
\subsection{Problem 5: channels}