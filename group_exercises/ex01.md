# Group Session 1

## Ex1. Parallelism and concurrency

Parallelism implies that execution run at the same time. 

Concurrent processes appear to be executed at the same time, but in reality is just an illusion provided by the OS. The two processes start at the same time and run and complete in overlapping time periods, but not necessary at the same time. 

Given that we have a mono-processor, can we use concurrency to speed up the program? 

**Yes!** Concurrency could even then speed up the process of executing programs. For example while another process is waiting (for I/O or requests), we can then execute another step in another task. 

Imagine having to download from multiple URL's. **Without concurrency, the CPU has to wait for the data to be downloaded for each URL before moving on.** By downloading all the data concurrently, the CPU will be better used and will overall complete the task faster. 


## Ex2. Pattern Finder

Given the following await code: 

```
string buffer;
bool done := false;

process Finder { 
    string line1;
    while (true) {
        wait for buffer to be full or done to be true ;
        if ( done ) break ;
        line1 := buffer ;
        signal that buffer is empty ;
        look for pattern in line1 ;
        if (pattern is line1){
            write line1; 
        }
    }
}

process Reader { # r e a d new l i n e s
    string line2 ;
    while ( true ) {
        read next line of input into line2 or set EOF after last line ;
        if (EOF) { done := true ; break ; }
        wait for buffer to be empty ;
        buffer := line2 ;
        signal that buffer is full ;
    }
}

```

### Part A: Add sync code for synchronizing access to buffer: 

Adding a lock to the critical sections. 
The suggested solution is to use a lock.
With await syntax, the solution is: 

```
string buffer;
bool done := false;
bool buffer_full := false; 

process Finder { 
    string line1;
    while (true) {
        //wait for buffer to be full or done to be true 
        if ( done ) break ;

        while(!buffer_full){ skip }
        line1 := buffer; 
        buffer_full:= false;

        look for pattern in line1 ;
        if (pattern is line1){
            write line1; 
        }
    }
}

process Reader { 
    string line2 ;
    while ( true ) {
        read next line of input into line2 or set EOF after last line ;
        if (EOF) { done := true ; break ; }

        // Appending data to the buffer again 
        while(buffer_full){ skip }
        buffer := line2;
        buffer_full := true; 
    }
}

```

### Part B: Extend the program to read two files 

To ensure that the algorithm is fair, we need to implement fairness into the processes. The best algorithm in this case, is the Ticket algorithm. 

> Notes: I think this is wrong

```
string buffer;
bool done := false;
bool buffer_full := false; 

int number := 1;
int next := 1;
int turn[1:n*2] := ([n*2] 0);

process Finder [i = 1 to n]{ 
    string line1;
    while (true) {
        //wait for buffer to be full or done to be true 
        if ( done ) break ;

        // take turn with fetch-add as atomic operation
        turn[i] = FA(number, a);

        while(turn[i] != next) {skip}; 
        while(!buffer_full){ skip }

        // CS
        line1 := buffer; 
        buffer_full:= false;
        next := next + 1

        look for pattern in line1 ;
        if (pattern is line1){
            write line1; 
        }
    }
}

process Reader [i = 1 to n]{ 
    string line2 ;
    while ( true ) {
        read next line of input into line2 or set EOF after last line ;
        if (EOF) { done := true ; break ; }

        // take turn with fetch-add as atomic operation
        turn[i] = FA(number, a);

        // Skip until turn 
        while(turn[i] != next) {skip}; 
        while(buffer_full){ skip }

        buffer := line2;
        buffer_full := true; 
        next := next + 1; 
    }
}

```

## Ext. 3 Producer consumer 

Change it so that the variable p is local to the producer process
and c is local to the consumer process, not global. Hence, those variables cannot be used to
synchronize access to buf. 

The following code, copies the array from the producer to the consumer. 


Original await code: 

```
int buffer, p:= 0; c:= 0;


process Producer{
    int a[N];
    while (p<N){
        <await (p == c); >
        buffer := a[p];
        p:= p+1; 
    }
}

process Consumer{
    int b[N];
    while(c<N){
        <await (p > c);>
        b[c] := buffer; 
        c:= c+1; 
    }
}
```

We can now not use the local variables. 
How can we then sync access to buffer?

```
int buffer;
int index; 


process Producer{
    int a[N];
    int p = 0; 
    while (p<N){
        <await (index == 0); >
        buffer := a[p];
        p:= p+1; 
        index:= index+1; 
    }
}

process Consumer{
    int b[N];
    int c = 0; 
    while(c<N){
        <await (index == 1);>
        b[c] := buffer; 
        c:= c+1; 
        index := 1; 
    }
}
```

The solution is having a variable that is either 0 or 1. 
By doing it this way, we ensure that each of them is excluding each other. 


## Ext. 4 Executions and atomicity 

### Part 1: 

Suppose each assignment statement is implemented by a single machine instruction and hence is atomic. How many possible executions are there? What are the possible final values of x and y?

```
int x := 0, y := 0; 

co 
    x:= x+1; # S1
    x:= x+2; # S2
||
    x:= x+2; # S3
    y:= y-x; # S4
oc

```

6 possible executions : 
- S1, S2, S3, S4
- S1, S3, S2, S4
- S1, S3, S4, S2
- S3, S1, S2, S4
- S3, S1, S4, S2
- S3, S4, S1, S2

Final values: 
- S1, S2, S3, S4 => x:= 5, y:= -5
- S1, S3, S2, S4 => x:= 5, y:= -5  
- S1, S3, S4, S2 => x:= 5, y:= -3
- S3, S1, S2, S4 => x:= 5, y:= -5
- S3, S1, S4, S2 => x:= 5, y:= -3
- S3, S4, S1, S2 => x:= 5, y:= -2

Final state
{x:=5 & (y:= -5 || y:= -3 || y:= -2)} 

### Part 2: 

Suppose each assignment statement is implemented by three atomic actions that load a register, add or subtract a value from that register, then store the result. How many possible executions are there now? What are the possible final values of x and y?


There is a formula for this 

n: processes
m: atomic statements in each 

n = 2,
m = 6

**executions = (n * m)! / m!^n**
           = 12! / 6!^2
           = 924! 

> Note to self. Does it matter that there are two statements in each process?


## Ext. 5 Interleaving, non-determinism, and atomicity

Program: 

```
int x:=2, y:=3;

co
    < x:=x+y > #S1
||
    < y:=x*y > #S2
```

### Part 1: Final values?


For the two processes with one atomic statement each:
- S1, S2 => x:= 5, y:= 15
- S2, S1 => x:= 8, y:= 6

{(x:=5, y:=15) || (x:=8, y:= 6)}

### Part 2: Final values? (with non-atomic operations)

Suppose the angle brackets are removed and each assignment statement is now implemented by three atomic actions: read the variables, add or multiply, and write to a variable. What are the possible final values of x and y now?

> There are three atomic operations, but I do not think we need to take into account them.This is also done in the example. Why?


Constraint: read must happen before write for each process. 

The following interleaving: 
- R1, W1, R2, W2 => x:= 5, y:= 15 
- R1, R2, W1, W2 => x:= 5, y:= 6 
- R1, R2, W2, W1 => x:= 5, y:= 6 
- R2, R1, W1, W2 => x:= 5, y:= 6 
- R2, R1, W2, W1 => x:= 5, y:= 6 
- R2, W2, R1, W2 => x:= 8, y:= 6

Final states: 
{ (x:= 5 & (y := 6 | y:= 15)) | (x:=8 & y:= 6) }