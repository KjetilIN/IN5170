# Exercise 4 - Channels and Message Passing

## Q1

Consider a filter process `Partition` having the following specifications. `Partition` receives unsorted integers values from one input channel `in` and send the values it receives to one of two output channels, `out1` or `out2`. Partition uses the first value v it receives to partition the input values into two sets. It sends all values less than or equal to v to `out1` and all values greater than v to out2. Finally, Partition sends v to `out1` and sends a sentinel EOS to both `out1` and `out2`. The end of the input stream is marked by a sentinel `EOS`. 

Develop an implementation of Partition. First, give predicates specifying the contents of the channels, then develop the body of Partition.


#### Solution 

Predicate that holds for all channel. 
First defining variables:
- let n be the number of values sent, including v, excluding EOS
- let i be the i'th value of in channel
- let m be the number of proper values (excluding m) send to out1, excluding EOS 

Then we chain what we know must be true at all the states:

```math
empty(in) \land \\
in[0] = v \land \\
\forall 1 <= i <= m \forall 1 <= j <= (n-m): out1[i] < out2[j] \land \\
\forall 1 <= i <= m : out1[i] <= v \land \\
\forall 1 <= i <= (n-m) : out2[i] > v \land \\
out1[m] = v \land \\
out1[m + 1] = EOS \land \\
out2[n + 1] = EOS \land

```



Implemented like this: 

```text
chan in(int), out1(int), out2(int);

process Partition{
    int v; 
    int current_val;

    // Take the two first input as v and then the next val
    receive in(v);
    receive in(current_val);

    // While not end of stream 
    while(current_val != EOS){
        if current_val < v{
            send out1(current_val);
        }else{
            send out2(current_val);
        }
        
        // Get new value from input channel 
        receive in(current_val);
    }

    // Send the V value at the end
    send out1(v);

    // Close the channels 
    close out1;
    close out2;
}
```

It fails if the input stream starts with EOS. Then the program needs to check for this.


## Q2

Consider the readers/writers problem defined in the lecture: There are reader and writer processes that share access to a database/shared data structure. Readers only read from the database and writers write to the database. A writer needs exclusive access to the database, so no other reader or writer should access the database at the same time. On the other hand, many readers can access the database at the same time. 

Develop a server process to implement access to the database that the readers and writers access. Show the reader and writer interfaces to the server. The processes should interact using asynchronous message passing.

#### Solution 

The solution uses two enums to represent what type of request, and the operation kind. Then it uses a single channel to send a request on.

We also have a reply channel with a boolean for all requests. This makes the client wait for acknowledgement. 

**Pattern for async into sync with channels:** sending and immediately waiting for acknowledgement 

The server has:
- A big while loop
- While loop is nested with the four cases based on what operation it is and its kind
- Queues for requests - FCFS queue that allows the server to be fair


```
// type of request it receives 
type client_kind = enum(READER, WRITER);
type op_kind = enum(REQUEST, RELEASE);

// Request channel to read request from
chan request(int clientID, client_kind cl_kind, op_kind operation);

// Channel with n slots for reply 
chan reply[n] (bool reply);

process server{
    // Queues for readers and writers
    queue readers;
    queue writers; 


    // Variables to write to when request is received 
    int clientID;
    int nr := 0;
    int nw := 0;
    client_kind cl_kind;
    op_kind operation

    // process requests
    while(true){
        receive request(clientID, cl_kind, operation)

        if (operation == REQUEST){
            if (cl_kind == READER){
                // Check if there is an active writer
                if (nw = 0 and empty(writers)){
                    // No writer, we can then just read
                    nr++;
                    send reply[clientID](true);
                }else{
                    // Add the reader to the queue
                    insert(readers, clientID);
                }
            }else{
                // Client is writer
                // If there is no active reader or writer, we add 
                if (nr = 0 and nw = 0){
                    nw++;
                    send reply[clientID](true);
                }else{
                    insert(writers, clientID);
                }
            }

        }else{
            // Operation is release 
            if (cl_kind == READER){
                nr := nr - 1;
                
                // If we can, release a writer
                if(nr = 0 and !empty(writer)){
                    remove(writers, clientID);
                    nw ++; 
                    send reply[clientID](true);
                }

            }else{
                // Client is writer
                nw := nw - 1;

                // If there is a reader waiting, we release all readers
                if (!empty(readers)){
                    while(!empty(readers)){
                        remove(readers, clientID);
                        nr ++;
                        send reply[clientID](true);
                    }
                }else if (!empty(writers)){
                    // Release a single writer 
                    remove(writers, clientID);
                    nw++;
                    send reply[clientID](true);
                }
            }
        }

    }
}

process client[i to n]{
    client_kind cl_kind; 
    bool reply; 

    while(true){
        // Send a request and wait for the reply
        send request(i, cl_kind, REQUEST);
        receive reply[i][reply];

        // Use the server!
        
        // Send release when done
        send request(i, cl_kind, RELEASE);

    }
}
```


